// lib/qr/payload.js
// Build and validate QR payloads for tickets.
// - Opaque tokens with >=128 bits entropy (base64url)
// - Signed JWTs with version + TTL
// - Parse "TKT:<version>:<data>" QR text format
//
// Requirements mapping:
//  - Security: tokens unguessable (>=128 bits entropy)
//  - Option B (JWT): signed payload with ticket_id, ttl, qr_version
//  - Validation endpoint should still check DB for final authority

import crypto from 'crypto';
import jwt from 'jsonwebtoken';

// ------------ Env & Defaults ------------
const DEFAULT_BYTES = Math.max(parseInt(process.env.QR_TOKEN_BYTES || '16', 10), 16); // >=128 bits
const QR_JWT_SECRET = process.env.QR_JWT_SECRET || process.env.JWT_SECRET || 'change_this_qr_secret';
const QR_JWT_TTL_SECONDS = Math.max(parseInt(process.env.QR_JWT_TTL_SECONDS || '0', 10), 0); // 0 = no exp
const QR_TEXT_PREFIX = 'TKT';

// ------------ Opaque Tokens -------------

/**
 * Generate an opaque, unguessable token (>=128-bit entropy).
 * Uses URL-safe base64 for compactness.
 *
 * @param {number} [bytes] - number of random bytes (min 16)
 * @returns {string} base64url token (no padding)
 */
export function generateOpaqueToken(bytes = DEFAULT_BYTES) {
  const n = Math.max(bytes, 16);
  return crypto.randomBytes(n).toString('base64url'); // URL-safe, shorter than hex
}

/**
 * Convenience: generate a token suitable for DB storage in tickets.qr_token.
 * @returns {string} token
 */
export function createQrToken() {
  return generateOpaqueToken();
}

// ------------ JWT Ticket Payloads ------------

/**
 * Sign a JWT for a ticket QR.
 * Payload fields:
 *   - sub: ticket_id (authority lives in DB)
 *   - v:   qr_version (integer)
 *   - typ: 'ticket'
 *
 * @param {{ ticketId: string, version?: number, ttlSeconds?: number, extra?: Record<string, any> }} p
 * @returns {string} signed JWT
 */
export function signTicketJwt({ ticketId, version = 1, ttlSeconds = QR_JWT_TTL_SECONDS, extra = {} }) {
  if (!ticketId || typeof ticketId !== 'string') {
    throw new Error('signTicketJwt: ticketId is required');
  }

  const payload = {
    sub: ticketId,
    v: version,
    typ: 'ticket',
    ...extra
  };

  const opts = {};
  if (ttlSeconds && Number.isFinite(ttlSeconds) && ttlSeconds > 0) {
    // jsonwebtoken expects seconds or string (e.g. "15m")
    opts.expiresIn = ttlSeconds;
  }

  return jwt.sign(payload, QR_JWT_SECRET, opts);
}

/**
 * Verify a JWT created by signTicketJwt.
 * Returns decoded payload { sub, v, typ, iat, exp? } or throws on invalid/expired.
 *
 * @param {string} token
 * @returns {Record<string, any>}
 */
export function verifyTicketJwt(token) {
  if (!token || typeof token !== 'string') {
    throw new Error('verifyTicketJwt: token is required');
  }
  const decoded = jwt.verify(token, QR_JWT_SECRET);
  // Minimal sanity checks
  if (decoded?.typ !== 'ticket' || !decoded?.sub) {
    throw new Error('verifyTicketJwt: invalid payload');
  }
  return decoded;
}

// ------------ QR Text Format ------------

/**
 * Build the text that goes into the QR image.
 * Format: "TKT:<version>:<data>"
 *
 * @param {{ data: string, version?: number }} p
 * @returns {string}
 */
export function buildQrText({ data, version = 1 }) {
  if (!data || typeof data !== 'string') {
    throw new Error('buildQrText: data must be a non-empty string');
  }
  return `${QR_TEXT_PREFIX}:${version}:${data}`;
}

/**
 * Parse the text from a QR code generated by buildQrText.
 * @param {string} text
 * @returns {{ prefix: string, version: number, data: string }} parsed
 */
export function parseQrText(text) {
  if (!text || typeof text !== 'string') {
    throw new Error('parseQrText: text is required');
  }
  const parts = text.split(':');
  if (parts.length < 3) {
    throw new Error('parseQrText: invalid format');
  }
  const [prefix, versionStr, ...rest] = parts;
  const data = rest.join(':'); // allow ':' inside data if needed
  const version = Number.parseInt(versionStr, 10);
  if (prefix !== QR_TEXT_PREFIX || !Number.isFinite(version) || !data) {
    throw new Error('parseQrText: invalid components');
  }
  return { prefix, version, data };
}

/**
 * Detect if data segment looks like a JWT (heuristic: x.y.z with base64url chars).
 * @param {string} data
 */
export function looksLikeJwt(data) {
  return typeof data === 'string' && /^\w+?\.\w+?\.\w+$/.test(data);
}

/**
 * Normalize a scanned QR text to a structured object.
 * Tries to parse JWT if present, otherwise returns opaque token.
 *
 * @param {string} qrText
 * @returns {{
 *   version: number,
 *   kind: 'jwt'|'opaque',
 *   token?: string,
 *   jwt?: string,
 *   decoded?: Record<string, any>
 * }}
 */
export function normalizeFromQrText(qrText) {
  const { version, data } = parseQrText(qrText);

  if (looksLikeJwt(data)) {
    // Try JWT verification; if verification fails, throw so caller can treat as invalid/expired.
    const decoded = verifyTicketJwt(data);
    return { version, kind: 'jwt', jwt: data, decoded };
  }

  // Opaque token path
  return { version, kind: 'opaque', token: data };
}

// ------------ Helpers for Issuance/Validation ------------

/**
 * Build payload data for a ticket to store/send:
 * - If `useJwt` is true, returns a signed JWT string.
 * - Else, returns a fresh opaque token.
 *
 * Store the returned `tokenOrJwt` in DB (tickets.qr_token) and the `version` in tickets.qr_version.
 *
 * @param {{ ticketId: string, useJwt?: boolean, version?: number, ttlSeconds?: number }} p
 * @returns {{ tokenOrJwt: string, version: number, kind: 'jwt'|'opaque' }}
 */
export function createTicketPayload({ ticketId, useJwt = false, version = 1, ttlSeconds } = {}) {
  if (useJwt) {
    const jwtStr = signTicketJwt({ ticketId, version, ttlSeconds });
    return { tokenOrJwt: jwtStr, version, kind: 'jwt' };
  }
  const tok = generateOpaqueToken();
  return { tokenOrJwt: tok, version, kind: 'opaque' };
}
